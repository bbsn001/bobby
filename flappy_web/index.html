<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Bobby Bird</title>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      background: #0f1432;
      display: flex; justify-content: center; align-items: center;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    canvas { display: block; touch-action: none; user-select: none; }
  </style>
</head>
<body>

<!-- Nick screen — canvas jest ukryty dopóki gracz nie wpisze nicku -->
<div id="nickScreen" style="position:fixed;top:0;left:0;width:100%;height:100%;
  background:#0a0a2e;display:flex;flex-direction:column;align-items:center;
  justify-content:center;z-index:9999">
  <h1 style="color:#ffd700;font-size:2.2em;margin-bottom:24px">&#x1F426; Bobby Bird</h1>
  <input id="nickInput" type="text" maxlength="16" placeholder="Wpisz nick"
    autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
    style="font-size:16px;padding:0 16px;height:60px;width:70%;max-width:280px;
    border:2px solid #ffd700;border-radius:10px;background:#0f1432;color:#fff;
    text-align:center;outline:none;margin-bottom:16px" />
  <button id="startBtn"
    style="font-size:20px;padding:0 24px;height:60px;width:70%;max-width:280px;
    background:#ffd700;color:#0f1432;border:none;border-radius:10px;
    font-weight:bold;cursor:pointer;touch-action:manipulation">
    GRAJ
  </button>
  <p style="color:#888;font-size:.78rem;margin-top:14px">Wyniki trafią do globalnego rankingu</p>
</div>

<!-- Canvas ukryty do czasu wpisania nicku -->
<canvas id="gameCanvas" style="display:none"></canvas>

<script type="module">
// ── Firebase ──────────────────────────────────────────────────────────────────
import { initializeApp }                              from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
import { getFirestore, collection, doc,
         getDoc, setDoc,
         getDocs, query, orderBy, limit }             from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';

const firebaseConfig = {
  apiKey:            "AIzaSyCv02h10zIVw8DhrBhryiDnFIa_peZklKQ",
  authDomain:        "flappy-bobby.firebaseapp.com",
  projectId:         "flappy-bobby",
  storageBucket:     "flappy-bobby.firebasestorage.app",
  messagingSenderId: "79131027037",
  appId:             "1:79131027037:web:2224f6d16ef4f7e6a88fb4"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

async function saveScore(nick, score) {
  try {
    const ref  = doc(db, 'leaderboard', nick);
    const snap = await getDoc(ref);
    if (snap.exists()) {
      if (score > snap.data().score)
        await setDoc(ref, { nick, score, date: new Date() });
    } else {
      await setDoc(ref, { nick, score, date: new Date() });
    }
  } catch(e) { console.warn('Firestore save:', e); }
}
async function getTopScores() {
  try {
    const snap = await getDocs(
      query(collection(db, 'leaderboard'), orderBy('score', 'desc'), limit(10))
    );
    return snap.docs.map(d => d.data());
  } catch(e) { console.warn('Firestore fetch:', e); return []; }
}

// ── Canvas ────────────────────────────────────────────────────────────────────
const canvas = document.getElementById('gameCanvas');
const ctx    = canvas.getContext('2d');
const GW = 400, GH = 600;
const dpr = Math.min(window.devicePixelRatio || 1, 3); // cap at 3× — oszczędność RAM
canvas.width  = Math.round(GW * dpr);
canvas.height = Math.round(GH * dpr);
canvas.style.imageRendering = 'auto';
ctx.scale(dpr, dpr); // wszystkie rysowania używają logicznych GW/GH — DPR transparentny

function resize() {
  const s = Math.min(window.innerWidth / GW, window.innerHeight / GH);
  canvas.style.width  = (GW * s) + 'px';
  canvas.style.height = (GH * s) + 'px';
}
window.addEventListener('resize', resize);

// ── Constants ─────────────────────────────────────────────────────────────────
const GRAVITY = 0.45, JUMP_FORCE = -9.5, PIPE_SPEED = 2.55;
const PIPE_GAP = 175, PIPE_WIDTH = 72, PIPE_INTERVAL = 1750;
const BIRD_SIZE = 60, CLOUD_W = 70, DEATH_LIMIT = 10;

// ── Stars ─────────────────────────────────────────────────────────────────────
const STARS = Array.from({ length: 25 }, () => ({
  x: Math.random() * GW, y: Math.random() * GH * 0.75,
  r: Math.random() < 0.3 ? 1.5 : 1
}));

// ── Audio ─────────────────────────────────────────────────────────────────────
const bgMusic = new Audio('assets/music.mp3');
bgMusic.loop = true; bgMusic.volume = 0.3;

const kachingAudio  = new Audio('assets/kaching.wav');
kachingAudio.volume = 0.5;

const mumiaAudio    = new Audio('assets/mumia.mp3');    mumiaAudio.volume    = 1.0;
const dzwiek7Audio  = new Audio('assets/7.mp3');        dzwiek7Audio.volume  = 1.0;
const krystianAudio = new Audio('assets/krystian.mp3'); krystianAudio.volume = 1.0;

function startMusic() { bgMusic.currentTime = 0; bgMusic.play().catch(() => {}); }
function stopMusic()  { bgMusic.pause(); }

function playKaching() {
  const s = kachingAudio.cloneNode(); s.volume = 0.5; s.play().catch(() => {});
}

function playSpecialSound(sc) {
  if (sc <= 0) return;
  let snd = null;
  if      (sc % 100 === 0) snd = krystianAudio;
  else if (sc % 10  === 0) snd = mumiaAudio;
  else if (sc % 10  === 7) snd = dzwiek7Audio;
  if (snd) { snd.currentTime = 0; snd.play().catch(() => {}); }
}

// ── Images ────────────────────────────────────────────────────────────────────
let playerCanvas = null, cloudCanvas = null, cloudH = CLOUD_W;

function removeWhiteBg(img, w, h) {
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const cx = c.getContext('2d');
  cx.drawImage(img, 0, 0, w, h);
  try {
    const id = cx.getImageData(0, 0, w, h), d = id.data;
    for (let i = 0; i < d.length; i += 4)
      if (d[i] >= 200 && d[i+1] >= 200 && d[i+2] >= 200) d[i+3] = 0;
    cx.putImageData(id, 0, 0);
  } catch(_) {}
  return c;
}

await new Promise(resolve => {
  let pending = 2;
  const done = () => { if (--pending === 0) resolve(); };
  const pi = new Image(); pi.crossOrigin = 'anonymous';
  pi.onload  = () => { playerCanvas = removeWhiteBg(pi, pi.naturalWidth, pi.naturalHeight); done(); };
  pi.onerror = done; pi.src = 'assets/player.jpg';
  const ci = new Image(); ci.crossOrigin = 'anonymous';
  ci.onload = () => {
    cloudH = Math.max(1, Math.round(ci.naturalHeight * CLOUD_W / ci.naturalWidth));
    cloudCanvas = removeWhiteBg(ci, CLOUD_W, cloudH); done();
  };
  ci.onerror = done; ci.src = 'assets/score.jpg';
});

// ── Nick screen ───────────────────────────────────────────────────────────────
let playerNick = '';
const nickScreen = document.getElementById('nickScreen');
const nickInput  = document.getElementById('nickInput');
const startBtn   = document.getElementById('startBtn');

function submitNick() {
  const val = nickInput.value.trim();
  if (!val) {
    nickInput.style.borderColor = '#dc3232';
    return;
  }
  nickInput.style.borderColor = '#ffd700';
  playerNick = val.slice(0, 16);
  // Ukryj ekran nicku, pokaż canvas, dopiero teraz uruchom pętlę
  nickScreen.style.display = 'none';
  canvas.style.display = 'block';
  resize();
  requestAnimationFrame(loop);
}

let nickSubmitted = false;   // guard — touchend + click mogą odpalić 2x
function onStartBtnActivate() {
  if (nickSubmitted) return;
  nickSubmitted = true;
  submitNick();
}

startBtn.addEventListener('click',    onStartBtnActivate);
startBtn.addEventListener('touchend', e => { e.preventDefault(); onStartBtnActivate(); });
nickInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') onStartBtnActivate();
  e.stopPropagation();   // nie pozwól Spacji uruchomić gry
});
nickInput.focus();

// ── Game state ────────────────────────────────────────────────────────────────
let state      = 'waiting';
let deathCount = 0;
let score      = 0;
let pipes      = [];
let pipeTimer  = 0;
let gameOverAt = 0;

let leaderboard        = [];
let leaderboardLoading = false;

const bird = {
  x: 80, y: GH / 2, vy: 0,
  _r:    { x: 0, y: 0, w: BIRD_SIZE - 16, h: BIRD_SIZE - 16 }, // cached — brak alokacji
  jump()     { this.vy = JUMP_FORCE; },
  update(dt) { const f = dt/16.667; this.vy += GRAVITY*f; this.y += this.vy*f; },
  rect()     { this._r.x = this.x + 8; this._r.y = this.y + 8; return this._r; }
};

function spawnPipe() {
  const gc = GH/4 + Math.random() * (GH/2);
  pipes.push({ x: GW, topH: gc - PIPE_GAP/2, botY: gc + PIPE_GAP/2,
               passed: false, collected: false });
}
function resetGame() {
  bird.x = 80; bird.y = GH/2; bird.vy = 0;
  pipes = []; pipeTimer = 0; score = 0;
  leaderboard = []; leaderboardLoading = false;
  stopMusic(); state = 'waiting';
}
function startGame() { state = 'playing'; bird.jump(); startMusic(); }

async function die() {
  deathCount++;
  stopMusic();
  gameOverAt = performance.now();
  state = deathCount >= DEATH_LIMIT ? 'youlose' : 'gameover';

  leaderboardLoading = true;
  leaderboard = [];
  await saveScore(playerNick, score);
  leaderboard = await getTopScores();
  leaderboardLoading = false;
}

function overlaps(a, b) {
  return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
}

// ── Reusable scratch rects (brak alokacji w pętli gry) ────────────────────────
const _cr = { x: 0, y: 0, w: CLOUD_W,    h: 0 }; // cloud
const _pr = { x: 0, y: 0, w: PIPE_WIDTH, h: 0 }; // pipe (top i bottom naprzemian)

// ── Update ────────────────────────────────────────────────────────────────────
function update(dt) {
  if (state === 'gameover') {
    if ((performance.now() - gameOverAt) / 1000 >= 3) resetGame();
    return;
  }
  if (state !== 'playing') return;

  bird.update(dt);

  pipeTimer += dt;
  if (pipeTimer >= PIPE_INTERVAL) { spawnPipe(); pipeTimer = 0; }

  const f = dt / 16.667;
  for (const p of pipes) {
    p.x -= PIPE_SPEED * f;
    if (!p.passed && p.x + PIPE_WIDTH < bird.x) p.passed = true;
  }
  pipes = pipes.filter(p => p.x + PIPE_WIDTH > 0);

  const br = bird.rect();

  if (cloudCanvas) {
    for (const p of pipes) {
      if (!p.collected) {
        _cr.x = p.x + PIPE_WIDTH/2 - CLOUD_W/2;
        _cr.y = (p.topH + p.botY)/2 - cloudH/2;
        _cr.h = cloudH;
        if (overlaps(br, _cr)) {
          p.collected = true;
          score++;
          playKaching();
          playSpecialSound(score);
        }
      }
    }
  }

  if (bird.y > GH || bird.y < -BIRD_SIZE) { die(); return; }
  for (const p of pipes) {
    _pr.x = p.x;
    _pr.y = 0;      _pr.h = p.topH;
    if (overlaps(br, _pr)) { die(); return; }
    _pr.y = p.botY; _pr.h = GH - p.botY;
    if (overlaps(br, _pr)) { die(); return; }
  }
}

// ── Draw helpers ──────────────────────────────────────────────────────────────
function txt(str, x, y, font, color, align = 'center') {
  ctx.font = font; ctx.fillStyle = color; ctx.textAlign = align;
  ctx.fillText(str, x, y);
}
function overlay(a) { ctx.fillStyle=`rgba(0,0,0,${a})`; ctx.fillRect(0,0,GW,GH); }

function drawPipe(p) {
  const cx = p.x-10, cw = PIPE_WIDTH+20, ch = 28;
  if (p.topH > 0) {
    ctx.fillStyle='#22b422'; ctx.fillRect(p.x,0,PIPE_WIDTH,p.topH);
    ctx.fillStyle='#127812'; ctx.fillRect(cx,p.topH-ch,cw,ch);
  }
  if (p.botY < GH) {
    ctx.fillStyle='#22b422'; ctx.fillRect(p.x,p.botY,PIPE_WIDTH,GH-p.botY);
    ctx.fillStyle='#127812'; ctx.fillRect(cx,p.botY,cw,ch);
  }
}
function drawBirdAt(x, y, angle) {
  ctx.save();
  ctx.translate(x + BIRD_SIZE/2, y + BIRD_SIZE/2);
  ctx.rotate(angle * Math.PI / 180);
  if (playerCanvas)
    ctx.drawImage(playerCanvas, -BIRD_SIZE/2, -BIRD_SIZE/2, BIRD_SIZE, BIRD_SIZE);
  else {
    ctx.fillStyle='#ffd700';
    ctx.beginPath(); ctx.arc(0,0,BIRD_SIZE/2-4,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

function drawLeaderboard(y0) {
  txt('\uD83C\uDFC6 TOP 10', GW/2, y0, 'bold 15px Arial', '#ffd700');
  if (leaderboardLoading) {
    txt('Ładowanie wyników...', GW/2, y0+24, '14px Arial', '#888');
    return;
  }
  if (!leaderboard.length) {
    txt('Brak wyników', GW/2, y0+24, '14px Arial', '#888');
    return;
  }
  leaderboard.forEach((e, i) => {
    const ry = y0 + 22 + i * 23;
    const isMe = e.nick === playerNick && e.score === score;
    const color = isMe ? '#ffd700' : (i < 3 ? '#fff' : '#a0a0a0');
    ctx.font = '14px Arial'; ctx.fillStyle = color;
    ctx.textAlign = 'left';  ctx.fillText(`${i+1}. ${e.nick}`, 22, ry);
    ctx.textAlign = 'right'; ctx.fillText(String(e.score), GW-22, ry);
  });
}

// ── Screens ───────────────────────────────────────────────────────────────────
function drawWaiting() {
  overlay(0.35);
  txt('Bobby Bird', GW/2, GH/4+10, 'bold 52px Arial', '#ffd700');
  const hy = GH/2 - BIRD_SIZE/2 + Math.sin(performance.now()/333)*12;
  drawBirdAt(GW/2 - BIRD_SIZE/2, hy, 0);
  if (Math.floor(performance.now()/600) % 2 === 0)
    txt('Tap lub SPACJA aby zacząć', GW/2, GH*2/3+10, 'bold 20px Arial', '#fff');
}

function drawGameOver() {
  overlay(0.62);
  txt('GAME OVER', GW/2, 72, 'bold 44px Arial', '#dc3232');
  txt('Score: ' + score, GW/2, 108, 'bold 26px Arial', '#ffd700');
  ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(20, 122); ctx.lineTo(GW-20, 122); ctx.stroke();
  drawLeaderboard(138);
  ctx.beginPath(); ctx.moveTo(20, 395); ctx.lineTo(GW-20, 395); ctx.stroke();
  const rem = Math.max(0, 3-(performance.now()-gameOverAt)/1000).toFixed(1);
  txt('Restart za ' + rem + 's  \u2022  Tap aby teraz', GW/2, 420, '16px Arial', '#888');
}

function drawYouLose() {
  overlay(0.72);
  txt('YOU LOSE \uD83D\uDE02', GW/2, 80, 'bold 48px Arial', '#dc3232');
  txt('Score: ' + score, GW/2, 120, 'bold 26px Arial', '#ffd700');
  ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(20, 134); ctx.lineTo(GW-20, 134); ctx.stroke();
  drawLeaderboard(150);
  txt('Odśwież aby zagrać ponownie', GW/2, 430, '18px Arial', '#a0a0a0');
}

// ── Main draw ─────────────────────────────────────────────────────────────────
function draw() {
  ctx.fillStyle = '#0f1432'; ctx.fillRect(0,0,GW,GH);
  ctx.fillStyle = '#b4c8ff';
  for (const s of STARS) { ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); }

  for (const p of pipes) {
    drawPipe(p);
    if (cloudCanvas && !p.collected)
      ctx.drawImage(cloudCanvas, p.x+PIPE_WIDTH/2-CLOUD_W/2,
                    (p.topH+p.botY)/2-cloudH/2, CLOUD_W, cloudH);
  }
  if (state !== 'waiting') {
    drawBirdAt(bird.x, bird.y, Math.max(-35, Math.min(50, -bird.vy*3)));
  }

  txt(String(score), GW-15, 40, 'bold 32px Arial', '#fff', 'right');
  txt('Deaths: '+deathCount+'/10', 10, 36, '20px Arial', '#a0a0a0', 'left');

  if      (state === 'waiting')  drawWaiting();
  else if (state === 'gameover') drawGameOver();
  else if (state === 'youlose')  drawYouLose();
}

// ── Input (tylko canvas — popup jest poza drzewem canvas) ─────────────────────
function onAction() {
  if (state === 'youlose')   return;
  if (state === 'waiting')   { startGame(); return; }
  if (state === 'playing')   { bird.jump(); return; }
  if (state === 'gameover')  { resetGame(); return; }
}

document.addEventListener('keydown', e => {
  if (e.code === 'Space') { e.preventDefault(); onAction(); }
});
canvas.addEventListener('mousedown',  e => { e.preventDefault(); onAction(); });
canvas.addEventListener('touchstart', e => { e.preventDefault(); onAction(); }, { passive: false });

// ── Loop — uruchamiany dopiero po wpisaniu nicku ───────────────────────────────
let lastTime = 0;
function loop(now) {
  const dt = lastTime ? Math.min(now - lastTime, 50) : 16.667;
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
// Pętla NIE jest uruchamiana tutaj — startuje w submitNick()
</script>
</body>
</html>
